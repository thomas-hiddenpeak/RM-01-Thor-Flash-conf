#!/bin/bash

# SPDX-FileCopyrightText: Copyright (c) 2020-2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: MIT
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

# Usage: ./l4t_flash_from_kernel.sh
# This script flashes the target from the Network File Systems on the target or
# from the host using the images inside the flash package generated by
# l4t_create_flash_image_in_nfs

set -eo pipefail

log() {
	local LEVEL="${1}"
	local MESSAGE="${*:2}"
	local TIMESTAMP
	TIMESTAMP="$(date +"%T.%3N")"

	if [[ "${LEVEL}" == "Error" ]]; then
		echo -e "${TIMESTAMP} - ${LEVEL}: ${MESSAGE}" >&2
		echo -e "${TIMESTAMP} - ${LEVEL}: ${MESSAGE}" >/dev/kmsg
	else
		echo -e "${TIMESTAMP} - ${LEVEL}: ${MESSAGE}" | tee /dev/kmsg
	fi
}

log_info() {
	local MESSAGE="${*}"
	log "Info" "${MESSAGE}"
}

log_debug() {
	local MESSAGE="${*}"
	log "Debug" "${MESSAGE}"
}

log_warning() {
	local MESSAGE="${*}"
	log "Warning" "${MESSAGE}"
}

log_error() {
	local MESSAGE="${*}"
	log "Error" "${MESSAGE}"
}

function cleanup
{
	for f in "${LOG_DIR}"/*
	do
		if ! [ -f "${f}" ]; then
			break
		fi
		log_debug "$(cat "${f}")"
	done
	for i in "${error_message[@]}"
	do
		log_error "$i"
	done
	if [ "${qspi_only}" = "0" ] && [ "${host_mode}" = "0" ] && [ "${external_only}" = "0" ]; then
		# Only do this if we are flashing the internal emmc / sd from NFS flash
		if [ -f "/sys/block/${internal_emmc_boot0}/force_ro" ]; then
			echo 1 > "/sys/block/${internal_emmc_boot0}/force_ro"
		fi
		if [ -f "/sys/block/${internal_emmc_boot1}/force_ro" ]; then
			echo 1 > "/sys/block/${internal_emmc_boot1}/force_ro"
		fi
	fi
}

run_commmand_on_target()
{
	log_info "Run command: ${2} on root@fe80::1%${1}"
	sshpass -p root ssh -q -oServerAliveInterval=15 -oServerAliveCountMax=3 -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -6 "root@fe80::1%${1}" "$2";
}

function print_at_end
{
	local temp_file
	temp_file=$(mktemp "${LOG_DIR}/XXX")
	echo -e "${@}" > "${temp_file}"
}

function usage
{
	echo -e "
Usage: $0 [--external-only | --host-mode | --qspi-only | --no-reboot]
Where,
	--external-only             Skip flashing the internal storage
	--qspi-only                 Flashing the qspi storage only
	--host-mode                 Flashing options used when flashing using initrd
	--no-reboot                 Don't reboot after finishing
	--direct                    Flash directly to the external device that is attached to the host.
                                The external device is specified by EXTDEV_ON_HOST environment variable.
	--ekb-sn                    The serial number value retrieved from fuse
This script flashes the target using the kernel on NFS of the target or the host
using the images inside the flash package generated by l4t_create_flash_image_in_nfs

	"; echo;
	exit 1
}

function print_log
{
	if [ -z "${*}" ]; then
		return
	fi
	local end=$SECONDS
	local duration=$(( end - START ))
	echo -e "[ ${duration}]: ${SCRIPT_NAME}: ${*}"
}


get_disk_name() {
    local ext_dev="${1}"
    local disk=""

    # Normalize: accept with or without /dev/ prefix via regex groups
    # Try patterns from most specific to most general.

    # 1) NVMe partitions: nvme0n1p1 -> nvme0n1
    if [[ "$ext_dev" =~ ^(/dev/)?(nvme[0-9]+n[0-9]+)p[0-9]+$ ]]; then
        disk="${BASH_REMATCH[2]}"

    # 2) MMC partitions: mmcblk0p1 -> mmcblk0
    elif [[ "$ext_dev" =~ ^(/dev/)?(mmcblk[0-9]+)p[0-9]+$ ]]; then
        disk="${BASH_REMATCH[2]}"

    # 3) Loop partitions: loop0p1 -> loop0
    elif [[ "$ext_dev" =~ ^(/dev/)?(loop[0-9]+)p[0-9]+$ ]]; then
        disk="${BASH_REMATCH[2]}"

    # 4) SCSI/SATA/virtio/xen style: sda1, vda2, xvdb3 -> sda, vda, xvdb
    elif [[ "$ext_dev" =~ ^(/dev/)?(sd[^0-9]+)[0-9]+$ ]]; then
        disk="${BASH_REMATCH[2]}"
    elif [[ "$ext_dev" =~ ^(/dev/)?(vd[^0-9]+)[0-9]+$ ]]; then
        disk="${BASH_REMATCH[2]}"
    elif [[ "$ext_dev" =~ ^(/dev/)?(xvd[^0-9]+)[0-9]+$ ]]; then
        disk="${BASH_REMATCH[2]}"

    # 5) If it looks like a whole device already (no partition suffix),
    #    return the basename without /dev/ (still regex-based).
    elif [[ "$ext_dev" =~ ^(/dev/)?([a-zA-Z0-9._-]+)$ ]]; then
        disk="${BASH_REMATCH[2]}"

    else
        # Fallback: echo as-is
        disk="$ext_dev"
    fi

    echo "$disk"
}


function is_internal_device()
{
	if [ "${1}" = "${SDCARD_STORAGE_DEVICE}" ] ||
	   [ "${1}" = "${SDMMC_USER_DEVICE}" ] ||
	   [ "${1}" = "${NVME_STORAGE_DEVICE}" ] ||
	   [ "${1}" = "${UFS_STORAGE_DEVICE}" ]; then
			return 0;
	fi
	return 1;
}

function is_gpt_supported_device()
{
	if [ "${1}" = "${SDCARD_STORAGE_DEVICE}" ] ||
	   [ "${1}" = "${SDMMC_USER_DEVICE}" ] ||
	   [ "${1}" = "${UFS_STORAGE_DEVICE}" ] ||
	   [ "${1}" = "${NVME_STORAGE_DEVICE}" ] ||
	   [ "${1}" =  "${EXTERNAL_STORAGE_DEVICE}" ]; then
			return 0;
	fi
	return 1;
}

function is_not_qspi()
{
	if [ "${1}" = "${SDMMC_BOOT_DEVICE}" ] \
		|| [ "${1}" = "${SDMMC_USER_DEVICE}" ] \
		|| [ "${1}" = "${SDCARD_STORAGE_DEVICE}" ] \
		|| [ "${1}" = "${UFS_STORAGE_DEVICE}" ] \
		|| [ "${1}" = "${NVME_STORAGE_DEVICE}" ] \
		|| [ "${1}" = "${EXTERNAL_STORAGE_DEVICE}" ]; then
		return 0;
	fi
	return 1;
}

function is_sparse_image
{
	[ "$(xxd -p -s 0f -l 4 "${1}")" = "${SPARSE_FILE_MAGIC}" ]
}

function is_zstd_data
{
	file "${1}" | grep -q 'Zstandard'
}

function is_spi_flash
{
	if [ ! -f "${FLASH_INDEX_FILE}" ];then
		print_at_end "${FLASH_INDEX_FILE} is not found. Skipping spi flashing"
		return
	fi

	readarray index_array < "${FLASH_INDEX_FILE}"
	log_debug "Flash index file is ${FLASH_INDEX_FILE}"

	lines_num=${#index_array[@]}
	log_debug "Number of lines is $lines_num"

	max_index=$((lines_num - 1))
	log_debug "max_index=${max_index}"

	for i in $(seq 0 ${max_index})
	do
		local item="${index_array[$i]}"

		# Try to search for a device that has type SPI flash(3)
		local device_type
		device_type=$(echo "${item}" | cut -d, -f 2 | \
			sed 's/^ //g' - | cut -d: -f 1)

		if [ "${device_type}" = "${SPI_DEVICE}" ];then
			return 0
		fi
	done
	return 1
}

function write_to_spi
{

	if [ ! -f "${FLASH_INDEX_FILE}" ];then
		print_at_end "Error: ${FLASH_INDEX_FILE} is not found"
		exit 1
	fi

	readarray index_array < "${FLASH_INDEX_FILE}"
	log_debug "Flash index file is ${FLASH_INDEX_FILE}"

	lines_num=${#index_array[@]}
	log_debug "Number of lines is $lines_num"

	max_index=$((lines_num - 1))
	log_debug "max_index=${max_index}"

	for i in $(seq 0 ${max_index})
	do
		local item="${index_array[$i]}"
		# break if device type is other than SPI flash(3) as only generating
		# image for SPI flash(3)
		local device_type
		device_type=$(echo "${item}" | cut -d, -f 2 | \
			sed 's/^ //g' - | cut -d: -f 1)

		if [ "${device_type}" != "${SPI_DEVICE}" ];then
			continue
		fi

		# fill the partition image into the SPI image
		if ! write_to_spi_partition "${item}" /dev/mtd0; then
			exit 1
		fi
	done

	return 0
}

# When flashing in host mode, all of the USB gadget MSD appears as /dev/sd* on the host
# But on the target it actually can be backed by /dev/mmcblk0, /dev/mmcblk0boot0
# Therefore, we need to create a mapping to keep track of which USB gadget MSD
# corresponds to which storage device on the target
function fill_device_map
{
	if [[ "${host_mode}" = "0" ]]; then
		return 0
	fi
	device_map["${sd_emmc_dev}"]="${SD_EMMC_ONDEV}"
	device_map["${internal_emmc_boot0}"]="${INTERNAL_EMMCBOOT0_ONDEV}"
	device_map["${internal_emmc_boot1}"]="${INTERNAL_EMMCBOOT1_ONDEV}"
	if [ -n "${external_device}" ]; then
		device_map["${external_device}"]="${external_device_on_target}"
	fi
}

function fill_block_map
{
	block_dev_map["${UFS_STORAGE_DEVICE}"]="${ufs_dev}"
	block_dev_map["${SDCARD_STORAGE_DEVICE}"]="${sd_emmc_dev}"
	block_dev_map["${SDMMC_USER_DEVICE}"]="${sd_emmc_dev}"
   	block_dev_map["${NVME_STORAGE_DEVICE}"]="${nvme_dev}"

}

# Use the mapping to get the actual backing device
function get_dev_name_on_target
{
	local disk_name=
	local device_name="$1"
	local part_num
	if [[ "${host_mode}" = "0" ]]; then
		echo "${device_name}"
	else
		disk_name=$(get_disk_name "$(basename "${device_name}")")
		shopt -s extglob
		part_num=${device_name##"${disk_name}"}
		part_num=${part_num##"${part_num%%+([[:digit:]])}"}
		shopt -u extglob
		get_partition "${device_map["${disk_name}"]}" "${part_num}"
	fi
}

function write_to_spi_partition
{
	local item="${1}"
	local spi_image="${2}"
	local part_name
	local file_name
	local start_offset
	local file_size
	local part_size
	local sha1_chksum
	local ekb_filename
	local matched=false
	local wildcard_allowed_list=("*_eks")

	part_name=$(echo "${item}" | cut -d, -f 2 | sed 's/^ //g' - | cut -d: -f 3)
	file_name=$(echo "${item}" | cut -d, -f 5 | sed 's/^ //g' -)
	part_size=$(echo "${item}" | cut -d, -f 4 | sed 's/^ //g' -)
	start_offset=$(echo "${item}" | cut -d, -f 3 | sed 's/^ //g' -)
	file_size=$(echo "${item}" | cut -d, -f 6 | sed 's/^ //g' -)
	sha1_chksum=$(echo "${item}" | cut -d, -f 8 | sed 's/^ //g' -)

	if [[ "${part_name}" = *eks ]] && [ -n "${ekb_sn}" ]; then
		if [ -z "${device_sn}" ]; then
			log_error "EKB flashing: device SN is empty. Flash failed."
			return 1
		fi
		ekb_filename="$(find "${COMMON_IMAGES_DIR}/${INTERNAL}/ekb_db" -type f -name "*${device_sn}*" | head -1)"
		sha1_chksum=$(sha1sum "${ekb_filename}" | cut -d\  -f 1)
		file_size="$(stat --printf="%s" "${ekb_filename}")"
		file_name="ekb_db/$(basename "${ekb_filename}")"
	fi

	# check if -k <target_partname> is specified
	if [ -n "${target_partname}" ]; then
		if [[ "${part_name}" = ${target_partname} ]]; then
			# wildcard matching, check if exactly matching
			if [ "${part_name}" = "${target_partname}" ]; then
				# part_name and target_partname are exactly matching
				matched=true;
			else
				# wildcard matching, search allowed_list
				for item in "${wildcard_allowed_list[@]}"; do
					if [ "${target_partname}" = "${item}" ]; then
						log_debug "${part_name} is matching ${target_partname}"
						matched=true
						break
					fi
				done
			fi
		fi
		if [ ${matched} != true ]; then
			log_debug "Skip writing ${part_name}"
			return
		fi
	fi

	if [ -z "${file_name}" ];then
		log_warning "Skip writing ${part_name} partition as no image is \
specified"
		return 0
	fi

	log_debug "Writing ${file_name} (parittion: ${part_name}) into ${spi_image}"

	local part_image_file="${COMMON_IMAGES_DIR}/${INTERNAL}/${file_name}"
	if [ ! -f "${part_image_file}" ];then
		log_error "Image for partition ${part_name} is not found at \
${part_image_file}"
		return 1
	fi

	sha1_verify "${part_image_file}" "${sha1_chksum}"

	if [ -n "${target_partname}" ]; then
		log_debug "Erasing ${part_name} for ${file_size} bytes at ${start_offset}"
		if ! mtd_debug erase "${spi_image}" "${start_offset}" "${part_size}"; then
			log_error "Erasing ${part_name} for ${file_size} bytes at ${start_offset} failed"
			return 1
		fi
	fi

	log_debug "Writing ${part_image_file} (${file_size} bytes) into "\
		"${spi_image}:${start_offset}"
	if ! mtd_debug write "${spi_image}" "${start_offset}" "${file_size}" \
		"${part_image_file}"; then
		log_error "Writing ${part_image_file} (${file_size} bytes) into \
${spi_image}:${start_offset} failed"
		return 1
	fi
	if [ "${part_name}" = "BCT" ]; then
		# set per chip erase_block size
		local BRBCT_SLOT_SIZE=16384
		log_debug "QSPI erase block size is ${BRBCT_SLOT_SIZE}"

		local blocksize=512
		local rounded_slot_size=$((((BRBCT_SLOT_SIZE + blocksize - 1) / blocksize ) * blocksize ))
		local num_copies=$((part_size / rounded_slot_size))
		if [ "${rounded_slot_size}" -lt "${file_size}" ]; then
			log_error "BCT file size(${file_size}) is bigger than the slot size(${rounded_slot_size}) "
			return 1
		fi
		# i should start from 1 because the first BCT copy has been written above
		log_debug "Writing ${num_copies} copies of ${part_image_file}"
		for (( i=1; i<num_copies; i++ ))
		do
			start_offset=$((i * rounded_slot_size))
			log_debug "Writing ${part_image_file} (${file_size} bytes) into " \
			"${spi_image}:${start_offset}"
			if ! mtd_debug write "${spi_image}" "${start_offset}" "${file_size}" \
				 "${part_image_file}"; then
				log_error "Writing ${part_image_file} (${file_size} bytes) into \
					${spi_image}:${start_offset} failed"
				return 1
			fi
		done
	fi
}

# Verify sha1 checksum for image
# @file_image: file for caculating check sum
# @sha1chksum: sha1 check sum
function sha1_verify
{
	local file_image="${1}"
	local sha1_chksum="${2}"

	if [ -z "${sha1_chksum}" ];then
		log_error "Passed-in sha1 checksum is NULL"
		return 1
	fi

	if [ ! -f "${file_image}" ];then
		log_error "$file_image is not found !!!"
		return 1
	fi

	local sha1_chksum_gen
	sha1_chksum_gen=$(sha1sum "${file_image}" | cut -d\  -f 1)
	if [ "${sha1_chksum_gen}" = "${sha1_chksum}" ];then
		log_debug "Sha1 checksum matched for ${file_image}"
		return 0
	else
		log_error "Sha1 checksum does not match (${sha1_chksum_gen} \
!= ${sha1_chksum}) for ${file_image}"
		return 1
	fi
}

# This function read and write partitions using the infile and outfile name
# ,the infile offset and theout file offset, and the total size given.
function read_write_file
{
	local infile="${1}"
	local outfile="${2}"
	local inoffset="${3}"
	local outoffset="${4}"
	local size="${5}"

	if [ ! -e "${infile}" ];then
		log_error "Input file ${infile} is not found"
		return 1
	fi

	if [ "${size}" -eq 0 ];then
		log_error "The size of bytes to be read is ${size}"
		return 1
	fi

	local M_BYTES=$((1024 * 1024))
	local inoffset_align_M=$((inoffset % M_BYTES))
	local outoffset_align_M=$((outoffset % M_BYTES))

	# Try 1M block size first for best performance
	if [ "${inoffset_align_M}" -eq 0 ] && [ "${outoffset_align_M}" -eq 0 ];then
		local block=$((size / M_BYTES))
		local remainder=$((size % M_BYTES))
		local inoffset_blk=$((inoffset / M_BYTES))
		local outoffset_blk=$((outoffset / M_BYTES))

		log_debug "${size} bytes from ${infile} to ${outfile}: 1MB block=${block} remainder=${remainder}"

		if [ ${block} -gt 0 ];then
			log_debug "dd if=${infile} of=${outfile} bs=1M skip=${inoffset_blk} seek=${outoffset_blk} count=${block}"
			dd if="${infile}" of="${outfile}" bs=1M skip="${inoffset_blk}" \
				seek="${outoffset_blk}" count="${block}" conv=notrunc status=progress
		fi
		if [ ${remainder} -gt 0 ];then
			local block_size=$((block * M_BYTES))
			local outoffset_rem=$((outoffset + block_size))
			local inoffset_rem=$((inoffset + block_size))
			log_debug "dd if=${infile} of=${outfile} bs=1 skip=${inoffset_rem} seek=${outoffset_rem} count=${remainder}"
			dd if="${infile}" of="${outfile}" bs=1 skip="${inoffset_rem}" \
				seek="${outoffset_rem}" count="${remainder}" conv=notrunc
		fi
		sync
		return 0
	fi

	# Fallback to 1K block size if not 1M aligned
	local inoffset_align_K=$((inoffset % K_BYTES))
	local outoffset_align_K=$((outoffset % K_BYTES))
	if [ "${inoffset_align_K}" -ne 0 ] || [ "${outoffset_align_K}" -ne 0 ];then
		log_debug "Offset is not aligned to K Bytes, no optimization is applied"
		log_debug "dd if=${infile} of=${outfile} bs=1 skip=${inoffset} seek=${outoffset} count=${size}"
		dd if="${infile}" of="${outfile}" bs=1 skip="${inoffset}" \
			seek="${outoffset}" count="${size}"
		return 0
	fi

	local block=$((size / K_BYTES))
	local remainder=$((size % K_BYTES))
	local inoffset_blk=$((inoffset / K_BYTES))
	local outoffset_blk=$((outoffset / K_BYTES))

	log_debug "${size} bytes from ${infile} to ${outfile}: 1KB block=${block} remainder=${remainder}"

	if [ ${block} -gt 0 ];then
		log_debug "dd if=${infile} of=${outfile} bs=1K skip=${inoffset_blk} seek=${outoffset_blk} count=${block}"
		dd if="${infile}" of="${outfile}" bs=1K skip="${inoffset_blk}" \
			seek="${outoffset_blk}" count="${block}" conv=notrunc
	fi
	if [ ${remainder} -gt 0 ];then
		local block_size=$((block * K_BYTES))
		local outoffset_rem=$((outoffset + block_size))
		local inoffset_rem=$((inoffset + block_size))
		log_debug "dd if=${infile} of=${outfile} bs=1 skip=${inoffset_rem} seek=${outoffset_rem} count=${remainder}"
		dd if="${infile}" of="${outfile}" bs=1 skip="${inoffset_rem}" \
			seek="${outoffset_rem}" count="${remainder}" conv=notrunc
	fi
	sync
	return 0
}

function flash_partition
{
	local file_name="${1}"
	local part_name="${2}"
	local start_offset="${3}"
	local file_size="${4}"
	local attributes="${5}"
	local sha1_chksum="${6}"
	local device="${7}"
	local location="${8}"
	local tmp_file=/tmp/tmp.img
	local file_image="${COMMON_IMAGES_DIR}/${location}/${file_name}"
	local sha1_chksum_gen=
	local res=0
	local tmp_size=0

	if [ ! -f "${file_image}" ];then
		print_at_end "Cannot find file ${file_image}"
		exit 1
	fi

	if is_sparse_image "${file_image}"; then
		if [ -n "${device}" ];then
			local device_name
			IFS='-' read -r -a attribute <<< "${attributes}"
			entry_id="${attribute[2]}"
			device_name=$(basename "${device}")
			write_sparse_image "/dev/$(get_partition "${device_name}" "${entry_id}")" "${file_image}"
			return 0
		fi
	fi

	# intended for massflash with backup images
	if is_zstd_data "${file_image}"; then
		if [ -n "${device}" ];then
			local device_name
			IFS='-' read -r -a attribute <<< "${attributes}"
			entry_id="${attribute[2]}"
			device_name=$(basename "${device}")
			write_zstd_image "/dev/$(get_partition "${device_name}" "${entry_id}")" "${file_image}"
			sync
			return 0
		fi
	fi

	if [ "${VERIFY_WRITE}" -eq 1 ];then
		# skip verifying SMD/SMD_b/kernel-bootctrl/kernel-bootctrl_b
		# paritions as the sha1 cheksum in the index file is generated
		# from the dummy image file other than the exact image file
		if [ "${part_name}" != "SMD" ] \
			&& [ "${part_name}" != "SMD_b" ] \
			&& [ "${part_name}" != "kernel-bootctrl" ] \
			&& [ "${part_name}" != "kernel-bootctrl_b" ];then
			if ! sha1_verify "${file_image}" "${sha1_chksum}"; then
				return 1
			fi
		fi

		# verify whether this partition has been writen
		rm -f "${tmp_file}"
		if [ -n "${device}" ];then
			if ! read_write_file "${device}" "${tmp_file}" \
				"${start_offset}" 0 "${file_size}";then
				log_error "Failed to read ${file_size} bytes from \
${device}:${start_offset} to ${tmp_file}"
				return 1
			fi
		else
			tmp_size=$((SDMMC_BOOT0_SIZE - start_offset))
			dd if="/dev/${internal_emmc_boot0}" of="${tmp_file}" skip="${start_offset}" \
				bs=1 count="${tmp_size}"
			tmp_size=$((file_size - tmp_size))
			dd if="/dev/${internal_emmc_boot1}" bs=1 count="${tmp_size}" >> "${tmp_file}"
		fi
		sync
		sha1_chksum_gen=$(sha1sum "${tmp_file}" | cut -d\  -f 1)
		if [ "${sha1_chksum_gen}" = "${sha1_chksum}" ];then
			log_debug "Partition ${part_name} has been updated, skip writing"
			return 0
		fi
	fi

	# write image
	if [ -n "${device}" ];then
		if ! read_write_file "${file_image}" "${device}" 0 \
			"${start_offset}" "${file_size}";then
			log_error "Failed to write ${file_size} bytes from ${file_image} to \
${device}:${start_offset}"
			return 1
		fi
	else
		tmp_size=$((SDMMC_BOOT0_SIZE - start_offset))
		log_debug "dd if=${file_image} of=${device} seek=${start_offset} bs=1"\
			" count=${tmp_size} conv=notrunc"
		dd if="${file_image}" of="/dev/${internal_emmc_boot0}" seek="${start_offset}" bs=1 \
			count="${tmp_size}" conv=notrunc

		dd if="${file_image}" of="/dev/${internal_emmc_boot1}" bs=1 skip="${tmp_size}" \
			conv=notrunc
	fi
	sync

	if [ "${VERIFY_WRITE}" -eq 1 ];then
		rm -f "${tmp_file}"
		# verify writing
		if [ -n "${device}" ];then
			if ! read_write_file "${device}" "${tmp_file}" \
				"${start_offset}" 0 "${file_size}"; then
				log_error "Failed to read ${file_size} bytes from \
${device}:${start_offset} to ${tmp_file}"
				return 1
			fi
		else
			tmp_size=$((SDMMC_BOOT0_SIZE - start_offset))
			log_debug "dd if=/dev/${internal_emmc_boot0} of=${tmp_file} skip=${start_offset} "\
				"bs=1 count=${tmp_size}"
			dd if="/dev/${internal_emmc_boot0}" of="${tmp_file}" skip="${start_offset}" \
				bs=1 count="${tmp_size}"
			tmp_size=$((file_size - tmp_size))
			log_debug "dd if=/dev/${internal_emmc_boot1} bs=1 count=${tmp_size} >>${tmp_file}"
			dd if="/dev/${internal_emmc_boot1}" bs=1 count="${tmp_size}" >> "${tmp_file}"
		fi

		# For SMD/SMD_B and kernel-bootctrl/kernel-bootctrl_b, the
		# sha1 chksum needs to be re-generated from the exact image file
		if [ "${part_name}" = "SMD" ] \
			|| [ "${part_name}" = "SMD_b" ] \
			|| [ "${part_name}" = "kernel-bootctrl" ] \
			|| [ "${part_name}" = "kernel-bootctrl_b" ];then
			log_debug "Re-generate sha1sum for the image ${file_image}"
			sha1_chksum=$(sha1sum "${file_image}" | cut -d\  -f 1)
		fi

		sha1_verify "${tmp_file}" "${sha1_chksum}"
	fi
	return "${?}"
}

flash_sdmmc_boot_partition()
{
	local start_offset=$3
	local file_size=$4
	local sdmmc_device=
	local args=("$@")
	local end_offset=

	start_offset=$((start_offset))
	file_size=$((file_size))
	end_offset=$((start_offset + file_size))
	if [ -z "${SDMMC_BOOT0_SIZE}" ]; then
		print_at_end "mmcblk0bootx is not available"
		exit 1
	fi
	if [ ${start_offset} -ge "${SDMMC_BOOT0_SIZE}" ]; then
		sdmmc_device=/dev/${internal_emmc_boot1}
		start_offset=$((start_offset - SDMMC_BOOT0_SIZE))
		args[2]=${start_offset}
	elif [ ${end_offset} -le "${SDMMC_BOOT0_SIZE}" ]; then
		sdmmc_device=/dev/${internal_emmc_boot0}
	else
		# partition cross over mmcblk0boot0 and mmcblk0boot1 and
		# it should be handled in special way
		sdmmc_device=""
	fi

	flash_partition "${args[@]}" "${sdmmc_device}" "${INTERNAL}"
	return $?
}

function flash_sdmmc_user_partition
{
	local sdmmc_device=/dev/${!#}

	flash_partition "${@:1:$#-1}" "${sdmmc_device}" "${INTERNAL}"
	return "${?}"
}

function flash_extdev_partition
{
	# external_device is going to be generated by
	# l4t_create_images_for_kernel_flash.sh
	local disk=

	disk="/dev/$(get_disk_name "${external_device}")"
	flash_partition "$@" "${disk}" "${EXTERNAL}"
	return "${?}"
}

# get_partition DEVICE COUNT
# - DEVICE: disk device or path (e.g., sda, /dev/sda, nvme0n1, /dev/loop0, /dev/mmcblk0p2)
# - COUNT:  partition number (1..N). If empty or 0, return the base disk path.
#
# Partitions naming rules:
#   - sd*, hd*, vd*, xvd*     -> sda1, vda1 (no 'p')
#   - nvme*, mmcblk*, loop*   -> nvme0n1p1, mmcblk0p1, loop0p1 (uses 'p')
function get_partition()
{
    local device="$1"
    local count="$2"

    local base dir disk sep=""
    base="${device##*/}"       # e.g., "sda" from "/dev/sda"
    dir="${device%$base}"      # e.g., "/dev/" or ""

    # 1) If a partition was provided, extract the disk correctly
    if   [[ "$base" =~ ^(nvme[0-9]+n[0-9]+)p([0-9]+)$ ]]; then
        disk="${BASH_REMATCH[1]}"; sep="p"
    elif [[ "$base" =~ ^(mmcblk[0-9]+)p([0-9]+)$ ]]; then
        disk="${BASH_REMATCH[1]}"; sep="p"
    elif [[ "$base" =~ ^(loop[0-9]+)p([0-9]+)$ ]]; then
        disk="${BASH_REMATCH[1]}"; sep="p"
    elif [[ "$base" =~ ^(sd[a-z]+)([0-9]+)$ ]]; then
        disk="${BASH_REMATCH[1]}"; sep=""
    elif [[ "$base" =~ ^(hd[a-z]+)([0-9]+)$ ]]; then
        disk="${BASH_REMATCH[1]}"; sep=""
    elif [[ "$base" =~ ^(vd[a-z]+)([0-9]+)$ ]]; then
        disk="${BASH_REMATCH[1]}"; sep=""
    elif [[ "$base" =~ ^(xvd[a-z]+)([0-9]+)$ ]]; then
        disk="${BASH_REMATCH[1]}"; sep=""
    else
        # 2) Not a recognized partition string; treat as a disk name
        disk="$base"
        # Decide the separator to use when *building* a partition name
        if [[ "$base" =~ ^(nvme[0-9]+n[0-9]+|mmcblk[0-9]+|loop[0-9]+)$ ]]; then
            sep="p"
        else
            sep=""
        fi
    fi

    # If count is empty or 0, return the disk itself
    if [[ -z "$count" || "$count" -eq 0 ]]; then
        printf '%s%s\n' "$dir" "$disk"
        return
    fi

    # Otherwise, construct the partition path
    printf '%s%s%s%s\n' "$dir" "$disk" "$sep" "$count"
}



function erase_partition()
{
	# sparse file
	if [ "${host_mode}" = "0" ]; then
		log_debug "blkdiscard -f ${1}"
		if ! blkdiscard -f "${1}"; then
			log_error "Cannot erase using blkdiscard. Write zero to partition ${1}"
			log_error "dd if=/dev/zero of=${1}"
			dd if=/dev/zero of="${1}" status=progress oflag=direct
		fi
	else
		local dev_name
		dev_name="/dev/$(get_dev_name_on_target "$(basename "${1}")")"
		if [ "${direct}" = 1 ]; then
			local option=()
			if blkdiscard -h | grep -q "\-f,"; then
				option=("-f")
			fi
			if ! blkdiscard "${option[@]}" "${dev_name}"; then
				log_error "Cannot erase using blkdiscard. Write zero to partition ${dev_name}"
				log_error "dd if=/dev/zero of=${dev_name}"
				dd if=/dev/zero of="${dev_name}" status=progress oflag=direct
			fi
		else
			run_commmand_on_target "${net}" \
			"if ! blkdiscard -f ${dev_name}; then
			echo Cannot erase before writing sparse image. Write zero to partition ${dev_name};
			dd if=/dev/zero of=${dev_name} status=progress oflag=direct; fi";
		fi
	fi
}

# function to write a sparse image to a dev node
# first argument is the destination dev node, second argument is the file to write
function write_sparse_image
{

	erase_partition "${1}"
	local simg2img="nvsimg2img"

	if ! command -v "${simg2img}" &> /dev/null; then
		if [ "${host_mode}" = "1" ] && [ "${direct}" != "1" ]; then
			print_at_end "ERROR: cannot find ${simg2img}. You might have set up your flashing env wrong"
			exit 1
		fi;

		# Running from NFS
		simg2img="${COMMON_IMAGES_DIR}/simg2img"
		if ! command -v "${simg2img}" &> /dev/null; then
			print_at_end "ERROR: cannot find ${simg2img}. You might have set up your flashing env wrong"
			exit 1
		fi;
	fi;
	echo "${simg2img} ${2} ${1}"
	"${simg2img}" "${2}" "${1}"
	chkerr "${simg2img} ${2} ${1} failed"
	sync
	return
}


# function to write a sparse image to a dev node
# first argument is the destination dev node, second argument is the file to write
function write_zstd_image
{
	erase_partition "${1}"
	if ! command -v "zstd" &> /dev/null; then
		print_at_end "ERROR: cannot find zstd. You might have set up your flashing env wrong"
		exit 1
	fi;
	log_debug "zstd -T0 -d ${2} -c | dd of=${1} conv=sparse status=progress bs=4096"
	zstd -T0 -d "${2}" -c | dd of="${1}" conv=sparse status=progress bs=4096
	chkerr "zstd -T0 -d ${2} -c | dd of=${1} conv=sparse status=progress bs=4096 failed"
	sync
	return
}


function chkerr ()
{
	# As it checks the exit code of previous statement before this function,
	# we have to use $?
	if [ "$?" -ne 0 ]; then
		if [ "$1" != "" ]; then
			print_at_end "$1";
		else
			print_at_end "failed.";
		fi;
		exit 1;
	fi;
	if [ "$1" = "" ]; then
		echo "done.";
	fi;
}

function wait_for_block_dev()
{
	local partition="${1}"
	local count=0
	while ! blockdev --getpbsz "/dev/${partition}" > /dev/null 2>&1
	do
		printf "..."
		count=$((count + 1))
		if [ "${count}" -ge "${maxcount}" ]; then
			echo "Timeout"
			exit 1
		fi
		sleep 1
	done
}

function do_write_storage
{
	local item="${1}"
	local count="${2}"
	local device_type
	local part_name
	local file_name
	local start_offset
	local file_size
	local attributes
	local sha1_chksum
	local partition
	local disk
	device_type=$(echo "${item}" | cut -d, -f 2 | sed 's/^ //g' - | cut -d: -f 1)
	part_name=$(echo "${item}" | cut -d, -f 2 | sed 's/^ //g' - | cut -d: -f 3)
	file_name=$(echo "${item}" | cut -d, -f 5 | sed 's/^ //g' -)
	start_offset=$(echo "${item}" | cut -d, -f 3 | sed 's/^ //g' -)
	file_size=$(echo "${item}" | cut -d, -f 6 | sed 's/^ //g' -)
	attributes=$(echo "${item}" | cut -d, -f 7 | sed 's/^ //g' -)
	sha1_chksum=$(echo "${item}" | cut -d, -f 8 | sed 's/^ //g' -)
	local res=0

	if [ -z "${file_name}" ];then
		log_warning "Skip writing ${part_name} partition as no image \
is specified"
		return 0
	fi

	if [ -n "${target_partname}" ] && [ "${target_partname}" != "${part_name}" ]; then
		log_debug "Skip writing ${part_name}"
		return
	fi

	log_debug "Writing ${part_name} partition with ${file_name}"
	# if this device is emmc's boot partitions
	if [ "${device_type}" = "${SDMMC_BOOT_DEVICE}" ];then
		flash_sdmmc_boot_partition "${file_name}" "${part_name}" \
			"${start_offset}" "${file_size}" "${attributes}" "${sha1_chksum}"
		res="${?}"
		if [ "${res}" -ne 0 ];then
			return "${res}"
		fi

	# if this device is emmc's user partitions
	elif is_internal_device "${device_type}" ;then
		block_device="${block_dev_map["${device_type}"]}"
		flash_sdmmc_user_partition "${file_name}" "${part_name}" \
			"${start_offset}" "${file_size}" "${attributes}" "${sha1_chksum}" "${block_device}"
		res="${?}"
	elif [ "${device_type}" = "${EXTERNAL_STORAGE_DEVICE}" ]; then
		flash_extdev_partition "${file_name}" "${part_name}" \
			"${start_offset}" "${file_size}" "${attributes}" "${sha1_chksum}"
		res="${?}"
	else
		log_error "Invalid device type ${device_type}"
		return 1
	fi
	log_debug "Writing ${part_name} partition done"
	return "${res}"
}

function do_write_APP
{
	local item="${1}"
	local external="${2}"
	local count="${3}"
	local file_image
	local sha1_file
	local sha1_chksum=
	local APP_partition=
	local device_type=
	local disk=
	local part_name
	local tool=mkfs.ext4
	local location=""
	local name=
	local ext=

	device_type=$(echo "$item" | cut -d, -f 2 | sed 's/^ //g' - | cut -d: -f 1)

	part_name=$(echo "${item}" | cut -d, -f 2 | sed 's/^ //g' - | cut -d: -f 3)

	if [ -n "${target_partname}" ] && [ "${target_partname}" != "${part_name}" ]; then
		log_debug "Skip writing ${part_name}"
		return
	fi


	if [ "${device_type}" = "${EXTERNAL_STORAGE_DEVICE}" ]; then
		if [ -n "${external_device}" ]; then
			APP_partition=/dev/$(get_partition "${external_device}" "${count}")
			location="${EXTERNAL}"
			ext="_ext"
		else
			log_error "External device is not specified"
			return 1
		fi
	elif is_internal_device "${device_type}"; then
		APP_partition="/dev/$(get_partition "${block_dev_map[${device_type}]}" "${count}")"
		location="${INTERNAL}"
	else
		log_error "Unsupported device type ${device_type}"
		return 1
	fi


	name=${part_name}${ext}
	# Check whether UDA image exists or not as it is optional.
	# Return directly if it does not exist
	if [ "${part_name}" == "UDA" ] && [ "${!name}" == "" ]; then
		log_debug "Skip writing UDA partition"
		return 0
	fi

	if [ "${!name}" == "" ]; then
		log_debug "Skip writing ${name} partition"
		return 0
	fi

	file_image="${COMMON_IMAGES_DIR}/${location}/${!name}"
	sha1_file="${file_image}.sha1sum"
	if [ ! -f "${file_image}" ];then
		log_error "${part_name} image ${file_image} is not found !!!"
		return 1
	fi

	if [ ! -f "${sha1_file}" ];then
		log_error "Sha1 checksum file ${sha1_file} is not found !!!"
		return 1
	fi

	if [ ! -e "${APP_partition}" ];then
		log_error "${part_name} paritiion ${APP_partition} is not found !!!"
		return 1
	fi

	# verify sha1 checksum
	# sha1_chksum=$(cat "${sha1_file}")
	# if ! sha1_verify "${file_image}" "${sha1_chksum}";then
	# 	return 1
	# fi

	# Using magic to check if this is a sparse file
	if is_sparse_image "${file_image}"; then
		write_sparse_image "${APP_partition}" "${file_image}"
		return 0
	fi

	if is_zstd_data "${file_image}" && [[ "${file_image}" == *.zst ]]; then
		write_zstd_image "${APP_partition}" "${file_image}"
		return 0
	fi

	# Check if this is a zstd compressed data
	if is_zstd_data "${file_image}"; then
		# tar file
		# format APP partition and mount it
		log_debug "Formatting ${part_name} partition ${APP_partition} ..."
		"${tool}" -F "${APP_partition}"
		log_debug "Formatting ${part_name} parition done"
		tmp_dir=$(mktemp -d -t ci-XXXXXXXXXX)

		if ! mount "${APP_partition}" "${tmp_dir}"; then
			log_error "Failed to mount ${part_name} partition ${APP_partition}"
			return 1
		fi

		# decompress APP image into APP partition
		log_debug "Formatting ${part_name} partition ${APP_partition} ..."
		# Intend to print sequence "\r" here
		log_debug "tar --checkpoint-action=\"ttyout=Hit %s checkpoint #%u%*\\r\" -x -I 'zstd -T0' -pf ${file_image} " "${COMMON_TAR_OPTIONS[@]}" " -C "\
			"${tmp_dir}"
		if ! tar --checkpoint-action="ttyout=Hit %s checkpoint #%u%*\r" -x -I 'zstd -T0' -pf "${file_image}" "${COMMON_TAR_OPTIONS[@]}" \
			-C "${tmp_dir}"; then
			log_error "Failed to decompress ${part_name} image into ${APP_partition}"
			# umount APP parition
			umount "${tmp_dir}"
			rm -rf "${tmp_dir}"
			return 1
		fi
		sync

		# umount APP parition
		umount "${tmp_dir}"
		rm -rf "${tmp_dir}"
		return 0
	fi

	# raw image. Simply dd to the destination
	# Use larger block size (1M) for better performance, sync at end instead of per-block
	dd if="${file_image}" of="${APP_partition}" status=progress bs=1M oflag=direct
	sync
	e2fsck -yfFt "${APP_partition}"
	resize2fs -fFp "${APP_partition}"
	sync
}

function create_gpt
{
	local device_type=
	local part_name=
	local start_offset=
	local part_size=
	local res=0
	local GPT_EXIST=false
	local index_file="${1}"
	local external="1"
	local disk=
	local size=
	local item


	if [ -z "${index_file}" ]; then
		index_file="${FLASH_INDEX_FILE}"
		external=""
	fi

	log_debug "Active index file is ${index_file}"
	readarray ACTIVE_INDEX_ARRAY < "${index_file}"


	lines_num=${#ACTIVE_INDEX_ARRAY[@]}
	log_debug "Number of lines is $lines_num"

	max_index=$((lines_num - 1))
	log_debug "max_index=${max_index}"

	local entry_id=0
	local shouldExpandLastPart=0
	local expandedPartId=0
	local has_gpt_supported_dev=0


	# The GPT must be the first partition flashed, so this block ensures that
	# the GPT exists and is flashed first.

	for i in $(seq 0 ${max_index})
	do
		item=${ACTIVE_INDEX_ARRAY[$i]}

		part_name=$(echo "$item" | cut -d, -f 2 | \
			sed 's/^ //g' - | cut -d: -f 3)

		device_type=$(echo "$item" | cut -d, -f 2 | \
			sed 's/^ //g' - | cut -d: -f 1)

		start_offset=$(echo "${item}" | cut -d, -f 3 | sed 's/^ //g' -)
		part_size=$(echo "${item}" | cut -d, -f 4 | sed 's/^ //g' -)
		IFS='-' read -r -a attribute <<< "$(echo "${item}" | cut -d, -f 7 | sed 's/^ //g' -)"


		if is_gpt_supported_device "${device_type}"; then
			has_gpt_supported_dev=1
			# device type equals 1 indicates internal user emmc storage
			# device type equals 9 indicates external storage

			disk="/dev/${block_dev_map["${device_type}"]}"
			if [ "${device_type}" = "${EXTERNAL_STORAGE_DEVICE}" ]; then
				# This is an external storage device so try to find the name of
				# the devnode here.
				disk="/dev/$(get_disk_name "${external_device}")"
				if ! [ -b "${disk}" ]; then
					print_at_end "Error: External storage device (${disk}) might be unavailable or not work correctly. Please unplug the power supply and reattach the external storage."
					exit 1
				fi
			fi

			if [ -z "${attribute[2]}" ]; then
				entry_id="$((entry_id + 1))"
			else
				entry_id="${attribute[2]}"
			fi
			if [ "${part_name}" = "primary_gpt" ]; then
				log_debug "writing item=${item}"
				# This recreates the mbr and clears gpt. In the case where mbr
				# is invalid or does not exist, this will help partx read gpt table
				flock -w 60 /var/lock/nvidiainitrdflash parted -s "${disk}" mklabel gpt
				do_write_storage "${item}" ""
				if ! flock -w 60 /var/lock/nvidiainitrdflash partprobe "${disk}"; then
					 print_at_end "Error: partprobe failed. This indicates that:\n" \
						"-   the xml indicates the gpt is larger than the device storage\n" \
						"-   the xml might be invalid\n" \
						"-   the device might have a problem.\n" \
						"Please make correction."
					exit 1
				fi

				GPT_EXIST=true
				entry_id=0
				continue
			elif [ "${part_name}" = "secondary_gpt" ]; then
				local device_size=
				device_size=$(blockdev --getsize64 "${disk}")
				do_write_storage "${item}" ""
				if [ $((start_offset + part_size)) -gt "${device_size}" ]; then
					print_at_end "Error: the ${disk} size $((start_offset + part_size)) set in \
partition layout xml is greater than the ${disk} actual size ${device_size}. Please make correction"
					exit 1
				elif [ $((start_offset + part_size)) -lt "${device_size}" ]; then
					print_at_end "The device size indicated in the partition \
layout xml is smaller than the actual size. This utility will try to fix the GPT."
					set +e
					echo -e "Fix\nFix" | parted ---pretend-input-tty "${disk}" print
					if [ "${shouldExpandLastPart}" = "1" ]; then
						log_debug "Expanding last partition to fill the storage device"
						# The size of extened rootfs partition must be 4KiB aligned
						max_size="$(((device_size - part_size - expandedPartStart) / 4096 * 4096))"
						if [ "${max_size}" -gt 0 ]; then
							expandedPartEnd="$((expandedPartStart + max_size - 1))"
							parted -s "${disk}" "unit B resizepart ${expandedPartId} ${expandedPartEnd}"
						fi
					fi
					set -e
				fi
			elif [ "${attribute[0]}" = "expand" ]; then
				shouldExpandLastPart="1"
				expandedPartId="${entry_id}"
				expandedPartStart="${start_offset}"
			fi

		fi
	done

	# if GPT does not exist exit.
	if [ "${GPT_EXIST}" != true ] && [ "${has_gpt_supported_dev}" -eq 1 ]; then
		print_at_end "The GPT does not exist in the index file"
		exit 1
	fi
}

function write_to_storage
{
	local device_type=
	local part_name=
	local start_offset=
	local part_size=
	local res=0
	local GPT_EXIST=false
	local index_file="${1}"
	local external="1"
	local disk=
	local size=
	local item


	if [ -z "${index_file}" ]; then
		index_file="${FLASH_INDEX_FILE}"
		external=""
	fi

	log_debug "Active index file is ${index_file}"
	readarray ACTIVE_INDEX_ARRAY < "${index_file}"


	lines_num=${#ACTIVE_INDEX_ARRAY[@]}
	log_debug "Number of lines is $lines_num"

	max_index=$((lines_num - 1))
	log_debug "max_index=${max_index}"

	local entry_id=0

	for i in $(seq 0 ${max_index})
	do
		item=${ACTIVE_INDEX_ARRAY[$i]}
		part_name=$(echo "${item}" | cut -d, -f 2 | \
			sed 's/^ //g' - | cut -d: -f 3)

		device_type=$(echo "${item}" | cut -d, -f 2 | \
			sed 's/^ //g' - | cut -d: -f 1)

		IFS='-' read -r -a attribute <<< "$(echo "${item}" | cut -d, -f 7 | sed 's/^ //g' -)"

		if is_not_qspi "${device_type}"; then
			log_debug "writing item=${item}"

			if [ "${part_name}" = "primary_gpt" ]; then
				entry_id=0
				if is_gpt_supported_device "${device_type}"; then
					continue
				fi
			elif [ "${part_name}" = "secondary_gpt" ] || [ "${part_name}" = "master_boot_record" ]; then
				# skip as we have already put these in
				if is_gpt_supported_device "${device_type}"; then
					continue
				fi
			fi
			if [ -z "${attribute[2]}" ]; then
				entry_id="$((entry_id + 1))"
			else
				entry_id="${attribute[2]}"
			fi
			# Starting writing partitions
			if [ "${part_name}" = "APP" ] || [ "${part_name}" = "APP_b" ] \
				|| [ "${part_name}" = "APP_ENC" ] || [ "${part_name}" = "APP_ENC_b" ] \
				|| [ "${part_name}" = "UDA" ]; then
				if ! do_write_APP "${item}" "${external}" "${entry_id}"; then
					print_at_end "Failed to write to ${part_name}"
					exit 1
				fi
			else
				if ! do_write_storage "${item}" "${entry_id}"; then
					print_at_end "Failed to write to ${part_name}"
					exit 1
				fi
			fi
		elif [ "${device_type}" = "${SPI_DEVICE}" ]; then
			continue
		fi
	done
}

function flash_qspi
{
	if [ "${host_mode}" = "0" ] && [ "${external_only}" = "0" ] && is_spi_flash; then
		log_info "Starting to flash the QSPI."
		if [ -z "${target_partname}" ]; then
			flash_erase /dev/mtd0 0 0
		fi
		write_to_spi

		log_info "Successfully flashed the QSPI."
	fi
}

function create_gpt_emmc
{
	if [ "${qspi_only}" = "0" ] && [ "${external_only}" = "0" ] && [[ -f "${FLASH_INDEX_FILE}" || -f "${FLASH_INDEX_FILE_UPI}" ]]; then
		log_info "Starting to create the GPT for the eMMC."
		local flashidx
		flashidx=""
		if [ -f "${FLASH_INDEX_FILE_UPI}" ]; then
			flashidx="${FLASH_INDEX_FILE_UPI}"
		fi
		create_gpt "${flashidx}"
		log_info "Successfully created the GPT for the eMMC."
		if [ "${host_mode}" = "1" ] && [ -z "${direct}" ]; then
			run_commmand_on_target "${net}" "partprobe /dev/${SD_EMMC_ONDEV}"
		fi
	fi
}

function create_gpt_extdev
{
	if [ "${qspi_only}" = "0" ] && [ -f "${FLASH_INDEX_FILE_EXT}" ]; then
		log_info "Starting to create the GPT for the external device."
		create_gpt "${FLASH_INDEX_FILE_EXT}"
		log_info "Successfully created the GPT for the external device."
		if [ "${host_mode}" = "1" ]  && [ -z "${direct}" ]; then
			run_commmand_on_target "${net}" "partprobe /dev/$(get_disk_name "${external_device_on_target}")"
		fi
	fi
}

function flash_emmc
{
	if [ "${qspi_only}" = "0" ] && [ "${external_only}" = "0" ] && [[ -f "${FLASH_INDEX_FILE}" || -f "${FLASH_INDEX_FILE_UPI}" ]]; then
		log_info "Starting to flash the eMMC."
		local flashidx
		flashidx=""
		if [ -f "${FLASH_INDEX_FILE_UPI}" ]; then
			flashidx="${FLASH_INDEX_FILE_UPI}"
		fi
		write_to_storage "${flashidx}"
		log_info "Successfully flashed the eMMC."
	fi
}

function flash_extdev
{
	if [ "${qspi_only}" = "0" ] && [ -f "${FLASH_INDEX_FILE_EXT}" ]; then
		log_info "Starting to flash the external device."
		write_to_storage "${FLASH_INDEX_FILE_EXT}"
		log_info "Successfully flashed the external device."
	fi
}

function verify_ekb_sn
{
	local odmid
	local odminfo
	local serial_number
	local ekb_filename

	if ! [ -x "${COMMON_IMAGES_DIR}/nv_fuse_read.sh" ]; then
		log_error "${COMMON_IMAGES_DIR}/nv_fuse_read.sh not found"
		return 1
	fi
	odmid="$("${COMMON_IMAGES_DIR}/nv_fuse_read.sh" odmid | cut -d ':' -f 2 | tr -d ' ')"
	odminfo="$("${COMMON_IMAGES_DIR}/nv_fuse_read.sh" odminfo | cut -d ':' -f 2 | tr -d ' ')"
	if [ -z "${odmid}" ] || [ -z "${odminfo}" ]; then
		log_error "odmid: (${odmid}) or odminfo: (${odminfo}) is empty. Flash failed."
		return 1
	fi
	serial_number="$(printf "%s-%s" "${odminfo: -4}" "${odmid#0x}")"
	ekb_filename="$(find "${COMMON_IMAGES_DIR}/${INTERNAL}/ekb_db" -type f -name "*${serial_number}*" | head -1)"
	if [ -z "${ekb_filename}" ]; then
		log_error "EKB file containing ${serial_number} not found. Flash failed."
		return 1
	fi

	log_info "Found the EKB image for device ${serial_number}"
	device_sn="${serial_number}"
}


trap cleanup EXIT

should_exit=""
LOG_DIR=$(mktemp -d)
VERIFY_WRITE=0
external_only=0
host_mode=0
qspi_only=0
no_reboot=0
error_message=()

COMMON_TAR_OPTIONS=( "--warning=no-timestamp" \
	"--numeric-owner" \
	"--xattrs" \
	"--xattrs-include=*")
K_BYTES=1024
COMMON_IMAGES_DIR=$(cd "$(dirname "${0}")" && pwd);
SCRIPT_NAME="l4t_flash_from_kernel"
readonly SDMMC_USER_DEVICE="1"
readonly SDCARD_STORAGE_DEVICE="6"
readonly SDMMC_BOOT_DEVICE="0"
readonly EXTERNAL_STORAGE_DEVICE="9"
readonly UFS_STORAGE_DEVICE="8"
readonly NVME_STORAGE_DEVICE="12"
readonly SPI_DEVICE="3"
readonly SPARSE_FILE_MAGIC="3aff26ed"
readonly INTERNAL="internal"
readonly EXTERNAL="external"
readonly SD_EMMC_ONDEV="mmcblk0"
readonly UFS_ONDEV="sda"
readonly NVME_ONDEV="nvme0n1p1"
readonly INTERNAL_EMMCBOOT0_ONDEV="mmcblk0boot0"
readonly INTERNAL_EMMCBOOT1_ONDEV="mmcblk0boot1"
internal_emmc_boot0="${INTERNAL_EMMC_BOOT0:-${INTERNAL_EMMCBOOT0_ONDEV}}"
internal_emmc_boot1="${INTERNAL_EMMC_BOOT1:-${INTERNAL_EMMCBOOT1_ONDEV}}"
maxcount=60
sd_emmc_dev="${SD_EMMC_DEV:-${SD_EMMC_ONDEV}}"
ufs_dev="${UFS_DEV:-${UFS_ONDEV}}"
nvme_dev="${NVME_DEF:-${NVME_ONDEV}}"
SDMMC_BOOT0_SIZE=""
ekb_sn=""
if blockdev --getsize64 "/dev/${internal_emmc_boot0}"; then
	SDMMC_BOOT0_SIZE=$(blockdev --getsize64 "/dev/${internal_emmc_boot0}")
fi
target_partname=""

opstr+="h-:k:"
while getopts "${opstr}" OPTION; do
	case $OPTION in
	h) usage; ;;
	k) target_partname="${OPTARG}"; ;;
	-) case ${OPTARG} in
	   external-only) external_only=1; ;;
	   host-mode) host_mode=1; no_reboot=1 ;;
	   qspi-only) qspi_only=1; ;;
	   no-reboot) no_reboot=1; ;;
	   direct) direct=1; host_mode=1; no_reboot=1; external_only=1; ;;
	   ekb-sn) ekb_sn=1; ;;
	   *) usage ;;
	   esac;;
	*)
	   usage
	   ;;
	esac;
done

START="${SECONDS}"

if [ "${USER}" != "root" ]; then
	log_error "${0} requires root privilege";
	exit 1;
fi

if [ "${qspi_only}" = "0" ] && [ "${host_mode}" = "0" ] && [ "${external_only}" = "0" ]; then
	# Only do this if we are flashing the internal emmc / sd from NFS flash
	if [ -f "/sys/block/${internal_emmc_boot0}/force_ro" ]; then
		echo 0 > "/sys/block/${internal_emmc_boot0}/force_ro"
	fi
	if [ -f "/sys/block/${internal_emmc_boot1}/force_ro" ]; then
		echo 0 > "/sys/block/${internal_emmc_boot1}/force_ro"
	fi
fi

FLASH_INDEX_FILE="${COMMON_IMAGES_DIR}/${INTERNAL}/flash.idx"
FLASH_INDEX_FILE_UPI="${COMMON_IMAGES_DIR}/${INTERNAL}/flash-upi.idx"
FLASH_INDEX_FILE_EXT="${COMMON_IMAGES_DIR}/${EXTERNAL}/flash.idx"

# Restore the flash configuration
# This file is generated by l4t_create_images_for_kernel_flash.sh
if [ -f "${COMMON_IMAGES_DIR}/${INTERNAL}/flash.cfg" ]; then
	source "${COMMON_IMAGES_DIR}/${INTERNAL}/flash.cfg"
fi
if [ -f "${COMMON_IMAGES_DIR}/${EXTERNAL}/flash.cfg" ]; then
	source "${COMMON_IMAGES_DIR}/${EXTERNAL}/flash.cfg"
fi
external_device="${EXTDEV_ON_HOST:-${external_device}}"
# external device name on the host might be different on target
# For example, on the host USB MSD gadget device might appear as /dev/sda
# but on the target the block device backing the USB MSD gadget device
# is called /dev/nvme0n1
external_device_on_target="${EXTDEV_ON_TARGET:-${external_device}}"
# Network interface to communicate with target
net="${TARGET_IP}"
declare -A device_map
declare -A block_dev_map
fill_device_map
fill_block_map
mkdir -p /var/lock

if [ ! -f "/proc/device-tree/serial-number" ]; then
	log_warning "Serial number sysfs node doesn't exist."
else
	SN=$(tr -d '\0' < "/proc/device-tree/serial-number")
	if [ -z "$SN" ]; then
		log_warning "Serial number sysfs node is null."
	else
		log_info "Serial Number: ${SN}"
	fi
fi

device_sn=""
if [ -n "${ekb_sn}" ] && [ "${external_only}" = "0" ]; then
	# set device_sn inside the function when success
	if ! verify_ekb_sn; then
		exit 1;
	fi
fi

# The GPT must be the first partition flashed, so this block ensures that
# the GPT exists and is flashed first. Moreover, creating GPT must be done
# sequentially otherwise horrible things will happen
if [ -z "${target_partname}" ]; then
	create_gpt_emmc
	create_gpt_extdev
fi

flash_qspi &
qspi=$!
flash_emmc &
emmc=$!
flash_extdev &
extdev=$!

if ! wait "${qspi}"; then
	error_message+=("Error flashing qspi")
	should_exit=1
fi

if ! wait "${emmc}"; then
	error_message+=("Error flashing emmc")
	should_exit=1
fi

if ! wait "${extdev}"; then
	error_message+=("Error flashing external device")
	should_exit=1
fi

wait

if [ -n "${should_exit}" ]; then
	exit 1
fi

if [ -z "${target_partname}" ]; then
	log_info "Flashing success"
else
	log_info "Flashing partition ${target_partname} done"
fi

if [ "${no_reboot}" = "0" ]; then
	log_info "The device is going to reboot in 5 seconds...."
	sleep 5
	reboot now
fi
